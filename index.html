<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced AI Drowsiness Detection System</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: linear-gradient(135deg, #0c0c0c 0%, #1a1a2e 50%, #16213e 100%);
            color: white;
            min-height: 100vh;
            overflow-x: hidden;
        }

        .app-container {
            display: grid;
            grid-template-areas: 
                "header header"
                "sidebar main"
                "logs logs";
            grid-template-rows: auto 1fr auto;
            grid-template-columns: 380px 1fr;
            min-height: 100vh;
            gap: 20px;
            padding: 20px;
        }

        @media (max-width: 1200px) {
            .app-container {
                grid-template-areas: 
                    "header"
                    "sidebar"
                    "main"
                    "logs";
                grid-template-columns: 1fr;
            }
        }

        .header {
            grid-area: header;
            background: rgba(255,255,255,0.08);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255,255,255,0.15);
            border-radius: 20px;
            padding: 25px;
            text-align: center;
            box-shadow: 0 8px 32px rgba(0,0,0,0.4);
        }

        .header h1 {
            font-size: 2.8rem;
            font-weight: 800;
            background: linear-gradient(135deg, #00d4aa, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 10px;
        }

        .sidebar {
            grid-area: sidebar;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .main-content {
            grid-area: main;
            background: rgba(255,255,255,0.08);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255,255,255,0.15);
            border-radius: 20px;
            padding: 25px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.4);
        }

        .logs-section {
            grid-area: logs;
            background: rgba(255,255,255,0.08);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255,255,255,0.15);
            border-radius: 20px;
            padding: 25px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.4);
            height: 320px;
        }

        .card {
            background: rgba(255,255,255,0.08);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255,255,255,0.15);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .card:hover {
            transform: translateY(-3px);
            box-shadow: 0 12px 40px rgba(0,0,0,0.4);
            border-color: rgba(255,255,255,0.25);
        }

        .video-container {
            position: relative;
            width: 100%;
            max-width: 800px;
            margin: 0 auto 25px;
            border-radius: 15px;
            overflow: hidden;
            box-shadow: 0 15px 50px rgba(0,0,0,0.5);
        }

        #videoElement {
            width: 100%;
            height: auto;
            display: block;
            background: #000;
        }

        #canvasOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
            gap: 15px;
            margin: 25px 0;
        }

        .metric-card {
            background: linear-gradient(145deg, rgba(0,0,0,0.4), rgba(0,0,0,0.2));
            padding: 20px;
            border-radius: 12px;
            text-align: center;
            border: 1px solid rgba(255,255,255,0.1);
            transition: all 0.3s ease;
        }

        .metric-card:hover {
            border-color: #00d4aa;
            transform: translateY(-2px);
        }

        .metric-value {
            font-size: 2rem;
            font-weight: 700;
            color: #00d4aa;
            margin-bottom: 5px;
        }

        .metric-label {
            font-size: 0.9rem;
            opacity: 0.8;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .alert-panel {
            background: linear-gradient(135deg, #ff3333, #cc0000);
            padding: 25px;
            border-radius: 15px;
            text-align: center;
            margin-bottom: 20px;
            transform: scale(0);
            opacity: 0;
            transition: all 0.4s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            border: 2px solid rgba(255,255,255,0.3);
        }

        .alert-panel.active {
            transform: scale(1);
            opacity: 1;
            animation: alertPulse 2s infinite;
        }

        @keyframes alertPulse {
            0%, 100% { box-shadow: 0 0 0 0 rgba(255, 51, 51, 0.5); }
            50% { box-shadow: 0 0 0 25px rgba(255, 51, 51, 0); }
        }

        .btn {
            background: linear-gradient(135deg, #00d4aa, #667eea);
            color: white;
            border: none;
            padding: 14px 28px;
            border-radius: 25px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            font-size: 14px;
            min-width: 140px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            box-shadow: 0 4px 15px rgba(0, 212, 170, 0.3);
        }

        .btn:hover:not(:disabled) {
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(0, 212, 170, 0.4);
            background: linear-gradient(135deg, #00e6c3, #7b8ff0);
        }

        .btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .btn-danger {
            background: linear-gradient(135deg, #ff3333, #cc0000);
            box-shadow: 0 4px 15px rgba(255, 51, 51, 0.3);
        }

        .btn-danger:hover:not(:disabled) {
            box-shadow: 0 8px 25px rgba(255, 51, 51, 0.4);
        }

        .btn-group {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            margin: 20px 0;
        }

        .status-indicator {
            width: 14px;
            height: 14px;
            border-radius: 50%;
            display: inline-block;
            margin-right: 10px;
            animation: pulse 2.5s infinite;
            box-shadow: 0 0 10px currentColor;
        }

        .status-connected { 
            background: #00d4aa; 
            color: #00d4aa;
        }
        .status-disconnected { 
            background: #ff3333; 
            color: #ff3333;
        }
        .status-connecting { 
            background: #ffaa00; 
            color: #ffaa00;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.7; transform: scale(0.95); }
        }

        .advanced-metrics {
            background: rgba(0,0,0,0.4);
            padding: 20px;
            border-radius: 12px;
            margin: 20px 0;
            border: 1px solid rgba(255,255,255,0.1);
        }

        .advanced-metrics h4 {
            color: #00d4aa;
            margin-bottom: 15px;
            font-size: 1.2rem;
        }

        .metrics-row {
            display: flex;
            justify-content: space-between;
            margin: 8px 0;
            padding: 8px 0;
            border-bottom: 1px solid rgba(255,255,255,0.05);
        }

        .metrics-row:last-child {
            border-bottom: none;
        }

        .log-container {
            background: rgba(0,0,0,0.5);
            border-radius: 10px;
            padding: 15px;
            height: 250px;
            overflow-y: auto;
            font-family: 'JetBrains Mono', 'Courier New', monospace;
            font-size: 13px;
            line-height: 1.5;
            border: 1px solid rgba(255,255,255,0.1);
        }

        .log-entry {
            margin-bottom: 4px;
            opacity: 0;
            animation: logFadeIn 0.5s ease forwards;
        }

        @keyframes logFadeIn {
            to { opacity: 1; }
        }

        .log-timestamp { color: #74b9ff; }
        .log-info { color: #00d4aa; }
        .log-warning { color: #ffaa00; }
        .log-error { color: #ff3333; }
        .log-success { color: #00d4aa; }

        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(12, 12, 12, 0.98);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 9999;
            backdrop-filter: blur(15px);
        }

        .loading-spinner {
            width: 80px;
            height: 80px;
            border: 6px solid rgba(255,255,255,0.1);
            border-top: 6px solid #00d4aa;
            border-radius: 50%;
            animation: spin 1s cubic-bezier(0.68, -0.55, 0.265, 1.55) infinite;
            margin-bottom: 30px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .progress-bar {
            width: 400px;
            height: 8px;
            background: rgba(255,255,255,0.1);
            border-radius: 4px;
            overflow: hidden;
            margin: 25px 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #00d4aa, #667eea);
            transition: width 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            border-radius: 4px;
        }

        .device-list {
            background: rgba(0,0,0,0.4);
            border-radius: 12px;
            padding: 15px;
            margin: 15px 0;
            max-height: 220px;
            overflow-y: auto;
            border: 1px solid rgba(255,255,255,0.1);
        }

        .device-item {
            background: rgba(255,255,255,0.08);
            border: 1px solid rgba(255,255,255,0.15);
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 10px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .device-item:hover {
            background: rgba(0, 212, 170, 0.1);
            border-color: #00d4aa;
            transform: translateX(8px);
        }

        .range-slider {
            width: 100%;
            height: 8px;
            border-radius: 4px;
            background: rgba(255,255,255,0.2);
            outline: none;
            -webkit-appearance: none;
            margin: 10px 0;
        }

        .range-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: linear-gradient(135deg, #00d4aa, #667eea);
            cursor: pointer;
            box-shadow: 0 3px 8px rgba(0,0,0,0.3);
            transition: all 0.2s ease;
        }

        .range-slider::-webkit-slider-thumb:hover {
            transform: scale(1.1);
        }

        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(255,255,255,0.1);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb {
            background: linear-gradient(135deg, #00d4aa, #667eea);
            border-radius: 4px;
        }

        .notification {
            position: fixed;
            top: 30px;
            right: 30px;
            background: linear-gradient(135deg, #ff3333, #cc0000);
            color: white;
            padding: 25px;
            border-radius: 12px;
            backdrop-filter: blur(20px);
            box-shadow: 0 15px 50px rgba(255, 51, 51, 0.5);
            transform: translateX(120%);
            transition: transform 0.5s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            z-index: 1000;
            max-width: 380px;
            border: 2px solid rgba(255,255,255,0.3);
        }

        .notification.show {
            transform: translateX(0);
        }
    </style>
</head>
<body>
    <div id="loadingOverlay" class="loading-overlay">
        <div class="loading-spinner"></div>
        <h2 id="loadingTitle">Loading Advanced AI Models</h2>
        <p id="loadingSubtitle">Initializing TensorFlow.js, MediaPipe, and custom detection algorithms...</p>
        <div class="progress-bar">
            <div class="progress-fill" id="progressFill" style="width: 0%"></div>
        </div>
        <small id="loadingDetails">Please wait while we prepare the enhanced system</small>
    </div>

    <div class="app-container" id="appContainer" style="display: none;">
        <header class="header">
            <h1>Advanced AI Drowsiness Monitor</h1>
            <p>Multi-Model AI • Real-time Eye Tracking • PERCLOS Analysis • Advanced Blink Detection</p>
        </header>

        <aside class="sidebar">
            <div class="card">
                <h3>System Status</h3>
                <div style="margin: 15px 0;">
                    <div style="margin-bottom: 12px;">
                        <span class="status-indicator status-disconnected" id="bluetoothIndicator"></span>
                        <strong>Bluetooth:</strong> <span id="bluetoothStatusText">Disconnected</span>
                    </div>
                    <div style="margin-bottom: 12px;">
                        <span class="status-indicator status-disconnected" id="cameraIndicator"></span>
                        <strong>Camera:</strong> <span id="cameraStatusText">Inactive</span>
                    </div>
                    <div style="margin-bottom: 12px;">
                        <span class="status-indicator status-disconnected" id="detectionIndicator"></span>
                        <strong>AI Detection:</strong> <span id="detectionStatusText">Standby</span>
                    </div>
                    <div>
                        <span class="status-indicator status-disconnected" id="loggingIndicator"></span>
                        <strong>Data Logging:</strong> <span id="loggingStatusText">Inactive</span>
                    </div>
                </div>
            </div>

            <div class="card">
                <h3>Advanced Metrics</h3>
                <div class="advanced-metrics">
                    <h4>Eye Analysis</h4>
                    <div class="metrics-row">
                        <span>Left EAR:</span>
                        <span id="leftEARDisplay">0.000</span>
                    </div>
                    <div class="metrics-row">
                        <span>Right EAR:</span>
                        <span id="rightEARDisplay">0.000</span>
                    </div>
                    <div class="metrics-row">
                        <span>PERCLOS (%):</span>
                        <span id="perclosDisplay">0.0</span>
                    </div>
                    <div class="metrics-row">
                        <span>Blink Rate:</span>
                        <span id="blinkRateDisplay">0.0/min</span>
                    </div>
                    
                    <h4 style="margin-top: 20px;">Detection States</h4>
                    <div class="metrics-row">
                        <span>Face Confidence:</span>
                        <span id="faceConfidenceDisplay">0%</span>
                    </div>
                    <div class="metrics-row">
                        <span>Head Pose:</span>
                        <span id="headPoseDisplay">Normal</span>
                    </div>
                    <div class="metrics-row">
                        <span>Drowsiness Level:</span>
                        <span id="drowsinessLevelDisplay">Normal</span>
                    </div>
                </div>
            </div>

            <div class="card">
                <h3>Bluetooth Control</h3>
                <div class="btn-group">
                    <button class="btn" onclick="scanBluetooth()" id="scanBtn">
                        Scan Devices
                    </button>
                    <button class="btn" onclick="sendTestSignal()" id="testBtn" disabled>
                        Test Signal
                    </button>
                </div>
                
                <div class="device-list" id="deviceList">
                    <div style="text-align: center; color: #888; padding: 20px; font-style: italic;">
                        No devices found. Click "Scan Devices" to search.
                    </div>
                </div>
            </div>

            <div class="card">
                <h3>Detection Settings</h3>
                <div style="margin: 20px 0;">
                    <label style="display: block; margin-bottom: 8px; font-weight: 600; color: #00d4aa;">
                        EAR Threshold: <span id="earThresholdValue">0.22</span>
                    </label>
                    <input type="range" class="range-slider" id="earThresholdSlider" 
                           min="0.15" max="0.35" step="0.01" value="0.22" 
                           oninput="updateEARThreshold(this.value)">
                    
                    <label style="display: block; margin: 20px 0 8px; font-weight: 600; color: #00d4aa;">
                        PERCLOS Threshold: <span id="perclosThresholdValue">20</span>%
                    </label>
                    <input type="range" class="range-slider" id="perclosThresholdSlider" 
                           min="10" max="40" step="2" value="20" 
                           oninput="updatePERCLOSThreshold(this.value)">
                           
                    <label style="display: block; margin: 20px 0 8px; font-weight: 600; color: #00d4aa;">
                        Sensitivity: <span id="sensitivityValue">Medium</span>
                    </label>
                    <input type="range" class="range-slider" id="sensitivitySlider" 
                           min="1" max="3" step="1" value="2" 
                           oninput="updateSensitivity(this.value)">
                </div>
            </div>
        </aside>

        <main class="main-content">
            <div id="alertPanel" class="alert-panel">
                <h2>⚠️ DROWSINESS DETECTED!</h2>
                <p>Driver showing signs of fatigue - Pull over safely</p>
                <p><strong>Alert Level: <span id="alertLevel">HIGH</span></strong></p>
            </div>

            <h3>Live AI Analysis Feed</h3>
            <div class="video-container">
                <video id="videoElement" autoplay muted playsinline width="640" height="480"></video>
                <canvas id="canvasOverlay" width="640" height="480"></canvas>
            </div>

            <div class="btn-group">
                <button class="btn" onclick="startCamera()" id="startCameraBtn">
                    Start Camera
                </button>
                <button class="btn" onclick="startDetection()" id="startDetectionBtn" disabled>
                    Start AI Detection
                </button>
                <button class="btn" onclick="toggleDataLogging()" id="dataLoggingBtn">
                    Start Logging
                </button>
                <button class="btn btn-danger" onclick="stopAllSystems()" id="stopAllBtn">
                    Stop All
                </button>
                <button class="btn" onclick="downloadCSV()" id="downloadBtn">
                    Export Data
                </button>
            </div>

            <div class="metrics-grid">
                <div class="metric-card">
                    <div class="metric-value" id="averageEARValue">0.000</div>
                    <div class="metric-label">Average EAR</div>
                </div>
                <div class="metric-card">
                    <div class="metric-value" id="blinkCountValue">0</div>
                    <div class="metric-label">Total Blinks</div>
                </div>
                <div class="metric-card">
                    <div class="metric-value" id="drowsyEventsValue">0</div>
                    <div class="metric-label">Drowsy Events</div>
                </div>
                <div class="metric-card">
                    <div class="metric-value" id="fpsValue">0</div>
                    <div class="metric-label">Processing FPS</div>
                </div>
                <div class="metric-card">
                    <div class="metric-value" id="sessionTimeValue">00:00:00</div>
                    <div class="metric-label">Session Time</div>
                </div>
                <div class="metric-card">
                    <div class="metric-value" id="dataRecordsValue">0</div>
                    <div class="metric-label">Data Records</div>
                </div>
            </div>
        </main>

        <section class="logs-section">
            <h3>Advanced System Activity Log</h3>
            <div class="log-container" id="logContainer"></div>
        </section>
    </div>

    <div class="notification" id="drowsinessNotification">
        <h3>🚨 CRITICAL DROWSINESS ALERT</h3>
        <p>High drowsiness level detected! Please pull over immediately for safety.</p>
    </div>

    <!-- Advanced AI Libraries -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.15.0/dist/tf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/blazeface@0.0.7/dist/blazeface.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/face-landmarks-detection@0.0.3/dist/face-landmarks-detection.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh@0.4.1633559619/face_mesh.js"></script>

    <script>
        // Enhanced Application State
        const AdvancedState = {
            // AI Models
            blazeFaceModel: null,
            faceMeshModel: null,
            
            // Hardware
            bluetoothDevice: null,
            bluetoothCharacteristic: null,
            videoStream: null,
            
            // Detection State  
            isDetecting: false,
            isCameraActive: false,
            faceDetected: false,
            faceConfidence: 0,
            
            // Advanced Eye Metrics
            leftEAR: 0,
            rightEAR: 0,
            averageEAR: 0,
            perclos: 0,
            blinkCount: 0,
            blinkRate: 0,
            drowsyEvents: 0,
            drowsinessLevel: 'Normal',
            
            // Blink Detection
            blinkBuffer: [],
            earHistory: [],
            blinkThreshold: 0.25,
            blinkFrames: 0,
            lastBlinkTime: 0,
            
            // PERCLOS Calculation
            perclosBuffer: [],
            perclosWindowSize: 60, // 2 seconds at 30fps
            closedFrameCount: 0,
            
            // Head Pose
            headPose: { pitch: 0, yaw: 0, roll: 0 },
            headPoseState: 'Normal',
            
            // Settings
            earThreshold: 0.22,
            perclosThreshold: 20,
            sensitivity: 2,
            alertFrames: 15,
            
            // Performance
            fps: 0,
            frameCount: 0,
            lastFpsUpdate: Date.now(),
            
            // Data Logging
            isLogging: false,
            csvData: [],
            sessionStart: null,
            recordCount: 0,
            
            // Bluetooth
            signalsSent: 0,
            lastCommand: 'None',
        };

        // Enhanced Eye Aspect Ratio Calculation
        function calculateAdvancedEAR(landmarks) {
            // More precise MediaPipe landmark indices for eyes
            const leftEyeIndices = {
                // Left eye landmarks (more comprehensive)
                outer: 33, inner: 133,
                top1: 159, top2: 158, top3: 157, top4: 173,
                bottom1: 144, bottom2: 145, bottom3: 153, bottom4: 154
            };
            
            const rightEyeIndices = {
                // Right eye landmarks (more comprehensive)
                outer: 362, inner: 263,
                top1: 386, top2: 385, top3: 384, top4: 398,
                bottom1: 373, bottom2: 374, bottom3: 380, bottom4: 381
            };
            
            function calculatePreciseEAR(eyeIndices) {
                if (!landmarks.scaledMesh || landmarks.scaledMesh.length < 468) {
                    return 0;
                }
                
                const points = {};
                Object.keys(eyeIndices).forEach(key => {
                    points[key] = landmarks.scaledMesh[eyeIndices[key]];
                });
                
                // Calculate multiple vertical distances for accuracy
                const v1 = euclideanDistance(points.top1, points.bottom1);
                const v2 = euclideanDistance(points.top2, points.bottom2);
                const v3 = euclideanDistance(points.top3, points.bottom3);
                const v4 = euclideanDistance(points.top4, points.bottom4);
                
                // Horizontal distance
                const h = euclideanDistance(points.outer, points.inner);
                
                // Weighted EAR calculation
                const ear = (v1 + v2 + v3 + v4) / (4.0 * h);
                return Math.max(0, ear);
            }
            
            const leftEAR = calculatePreciseEAR(leftEyeIndices);
            const rightEAR = calculatePreciseEAR(rightEyeIndices);
            const averageEAR = (leftEAR + rightEAR) / 2;
            
            return { left: leftEAR, right: rightEAR, average: averageEAR };
        }
        
        function euclideanDistance(point1, point2) {
            return Math.sqrt(Math.pow(point1[0] - point2[0], 2) + Math.pow(point1[1] - point2[1], 2));
        }

        // Advanced Blink Detection with State Machine
        function detectBlinks(earValue) {
            const currentTime = Date.now();
            
            // Add to EAR history for analysis
            AdvancedState.earHistory.push({ ear: earValue, timestamp: currentTime });
            
            // Keep only last 2 seconds of data
            const twoSecondsAgo = currentTime - 2000;
            AdvancedState.earHistory = AdvancedState.earHistory.filter(item => item.timestamp > twoSecondsAgo);
            
            // Blink detection state machine
            if (earValue < AdvancedState.blinkThreshold) {
                AdvancedState.blinkFrames++;
            } else {
                if (AdvancedState.blinkFrames >= 2 && AdvancedState.blinkFrames <= 15) {
                    // Valid blink detected
                    AdvancedState.blinkCount++;
                    AdvancedState.lastBlinkTime = currentTime;
                    log(`Blink detected #${AdvancedState.blinkCount} (${AdvancedState.blinkFrames} frames)`, 'info');
                }
                AdvancedState.blinkFrames = 0;
            }
            
            // Calculate blink rate per minute
            const oneMinuteAgo = currentTime - 60000;
            const recentBlinks = AdvancedState.earHistory.filter(item => 
                item.timestamp > oneMinuteAgo && item.ear < AdvancedState.blinkThreshold
            );
            AdvancedState.blinkRate = (recentBlinks.length / 60) * 60; // blinks per minute
        }

        // PERCLOS (Percentage of Eyelid Closure) Calculation
        function calculatePERCLOS(earValue) {
            // Add current EAR to PERCLOS buffer
            AdvancedState.perclosBuffer.push(earValue);
            
            // Maintain buffer size for rolling window
            if (AdvancedState.perclosBuffer.length > AdvancedState.perclosWindowSize) {
                AdvancedState.perclosBuffer.shift();
            }
            
            // Count frames where eyes are closed (EAR < threshold)
            const closedFrames = AdvancedState.perclosBuffer.filter(ear => ear < AdvancedState.earThreshold).length;
            
            // Calculate PERCLOS percentage
            if (AdvancedState.perclosBuffer.length > 0) {
                AdvancedState.perclos = (closedFrames / AdvancedState.perclosBuffer.length) * 100;
            }
            
            return AdvancedState.perclos;
        }

        // Head Pose Estimation
        function calculateHeadPose(landmarks) {
            if (!landmarks.scaledMesh || landmarks.scaledMesh.length < 468) {
                return { pitch: 0, yaw: 0, roll: 0, state: 'Unknown' };
            }
            
            // Key facial landmarks for pose estimation
            const noseTip = landmarks.scaledMesh[1];
            const leftEyeCorner = landmarks.scaledMesh[33];
            const rightEyeCorner = landmarks.scaledMesh[263];
            const chinBottom = landmarks.scaledMesh[18];
            const foreheadCenter = landmarks.scaledMesh[10];
            
            // Calculate yaw (left-right rotation)
            const eyeDistance = euclideanDistance(leftEyeCorner, rightEyeCorner);
            const leftNoseDistance = euclideanDistance(leftEyeCorner, noseTip);
            const rightNoseDistance = euclideanDistance(rightEyeCorner, noseTip);
            const yaw = Math.atan2(rightNoseDistance - leftNoseDistance, eyeDistance) * 180 / Math.PI;
            
            // Calculate pitch (up-down rotation)
            const faceHeight = euclideanDistance(foreheadCenter, chinBottom);
            const noseToForehead = euclideanDistance(noseTip, foreheadCenter);
            const pitch = Math.atan2(noseToForehead - faceHeight/2, faceHeight) * 180 / Math.PI;
            
            // Calculate roll (tilt)
            const eyeSlope = (rightEyeCorner[1] - leftEyeCorner[1]) / (rightEyeCorner[0] - leftEyeCorner[0]);
            const roll = Math.atan(eyeSlope) * 180 / Math.PI;
            
            // Determine head pose state
            let poseState = 'Normal';
            if (Math.abs(yaw) > 25) poseState = 'Turning';
            else if (Math.abs(pitch) > 20) poseState = 'Tilting';
            else if (Math.abs(roll) > 15) poseState = 'Rolling';
            
            return { pitch, yaw, roll, state: poseState };
        }

        // Advanced Drowsiness Analysis
        function analyzeDrowsiness() {
            const earValue = AdvancedState.averageEAR;
            const perclosValue = AdvancedState.perclos;
            const blinkRate = AdvancedState.blinkRate;
            
            let drowsinessScore = 0;
            let alertLevel = 'Normal';
            
            // EAR-based scoring
            if (earValue > 0) {
                if (earValue < 0.20) drowsinessScore += 3;
                else if (earValue < AdvancedState.earThreshold) drowsinessScore += 2;
                else if (earValue < 0.25) drowsinessScore += 1;
            }
            
            // PERCLOS-based scoring
            if (perclosValue > 50) drowsinessScore += 4;
            else if (perclosValue > AdvancedState.perclosThreshold) drowsinessScore += 3;
            else if (perclosValue > 15) drowsinessScore += 1;
            
            // Blink rate analysis
            if (blinkRate < 5) drowsinessScore += 2; // Too few blinks
            else if (blinkRate > 30) drowsinessScore += 1; // Too many blinks
            
            // Head pose consideration
            if (AdvancedState.headPoseState !== 'Normal') {
                drowsinessScore += 1;
            }
            
            // Apply sensitivity multiplier
            drowsinessScore *= (AdvancedState.sensitivity / 2);
            
            // Determine alert level
            if (drowsinessScore >= 6) {
                alertLevel = 'CRITICAL';
                AdvancedState.drowsinessLevel = 'Critical';
            } else if (drowsinessScore >= 4) {
                alertLevel = 'HIGH';
                AdvancedState.drowsinessLevel = 'High';
            } else if (drowsinessScore >= 2) {
                alertLevel = 'MODERATE';
                AdvancedState.drowsinessLevel = 'Moderate';
            } else {
                alertLevel = 'LOW';
                AdvancedState.drowsinessLevel = 'Normal';
            }
            
            return { score: drowsinessScore, level: alertLevel };
        }

        // Enhanced AI Model Initialization
        async function initializeAdvancedAI() {
            try {
                updateProgress(10, 'Initializing TensorFlow backend...');
                await tf.ready();
                log('TensorFlow.js backend ready', 'success');
                
                updateProgress(30, 'Loading BlazeFace detection model...');
                AdvancedState.blazeFaceModel = await blazeface.load();
                log('BlazeFace model loaded successfully', 'success');
                
                updateProgress(60, 'Loading advanced face mesh model...');
                AdvancedState.faceMeshModel = await faceLandmarksDetection.load(
                    faceLandmarksDetection.SupportedPackages.mediaPipeFacemesh,
                    { maxFaces: 1 }
                );
                log('MediaPipe FaceMesh model loaded successfully', 'success');
                
                updateProgress(90, 'Optimizing models for performance...');
                await new Promise(resolve => setTimeout(resolve, 1000));
                
                updateProgress(100, 'Advanced AI system ready!');
                setTimeout(showMainInterface, 1200);
                
                return true;
            } catch (error) {
                log(`Advanced AI initialization failed: ${error.message}`, 'error');
                updateProgress(100, `Error: ${error.message}`);
                setTimeout(() => {
                    showMainInterface();
                    log('Running in fallback mode', 'warning');
                }, 2000);
                return false;
            }
        }

        // Enhanced Detection Loop
        async function detectAdvancedDrowsiness() {
            if (!AdvancedState.isDetecting) return;
            
            const video = document.getElementById('videoElement');
            const canvas = document.getElementById('canvasOverlay');
            const ctx = canvas.getContext('2d');
            
            try {
                AdvancedState.frameCount++;
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                if (AdvancedState.blazeFaceModel && video.readyState >= 2) {
                    // Face detection with BlazeFace
                    const faces = await AdvancedState.blazeFaceModel.estimateFaces(video, false);
                    
                    if (faces.length > 0) {
                        const face = faces[0];
                        AdvancedState.faceDetected = true;
                        AdvancedState.faceConfidence = face.probability;
                        
                        // Draw face detection
                        drawAdvancedFaceBox(ctx, face);
                        
                        // Get detailed facial landmarks
                        if (AdvancedState.faceMeshModel) {
                            const landmarks = await AdvancedState.faceMeshModel.estimateFaces({
                                input: video,
                                returnTensors: false,
                                flipHorizontal: false,
                                predictIrises: true
                            });
                            
                            if (landmarks.length > 0) {
                                const faceLandmarks = landmarks[0];
                                
                                // Calculate advanced EAR
                                const earValues = calculateAdvancedEAR(faceLandmarks);
                                AdvancedState.leftEAR = earValues.left;
                                AdvancedState.rightEAR = earValues.right;
                                AdvancedState.averageEAR = earValues.average;
                                
                                // Advanced blink detection
                                detectBlinks(earValues.average);
                                
                                // Calculate PERCLOS
                                calculatePERCLOS(earValues.average);
                                
                                // Head pose estimation
                                AdvancedState.headPose = calculateHeadPose(faceLandmarks);
                                AdvancedState.headPoseState = AdvancedState.headPose.state;
                                
                                // Drowsiness analysis
                                const drowsinessAnalysis = analyzeDrowsiness();
                                
                                // Draw enhanced visualizations
                                drawEyeTracking(ctx, faceLandmarks);
                                drawAdvancedMetrics(ctx);
                                
                                // Alert handling
                                if (drowsinessAnalysis.level === 'CRITICAL' || drowsinessAnalysis.level === 'HIGH') {
                                    AdvancedState.drowsyEvents++;
                                    await sendBluetoothCommand('1');
                                    showAdvancedAlert(drowsinessAnalysis.level);
                                    log(`DROWSINESS ALERT: ${drowsinessAnalysis.level} (Score: ${drowsinessAnalysis.score.toFixed(1)})`, 'error');
                                } else {
                                    await sendBluetoothCommand('0');
                                }
                                
                                // Log detection data
                                logAdvancedData(drowsinessAnalysis);
                            }
                        }
                    } else {
                        // No face detected
                        AdvancedState.faceDetected = false;
                        resetDetectionValues();
                        logAdvancedData(null, 'No face detected');
                    }
                    
                    updateAdvancedUI();
                }
                
            } catch (error) {
                log(`Advanced detection error: ${error.message}`, 'error');
            }
            
            // Continue detection loop
            requestAnimationFrame(detectAdvancedDrowsiness);
        }

        // Enhanced Drawing Functions
        function drawAdvancedFaceBox(ctx, face) {
            ctx.strokeStyle = '#00d4aa';
            ctx.lineWidth = 3;
            ctx.setLineDash([5, 5]);
            
            const width = face.bottomRight[0] - face.topLeft[0];
            const height = face.bottomRight[1] - face.topLeft[1];
            
            ctx.strokeRect(face.topLeft[0], face.topLeft[1], width, height);
            
            // Face confidence indicator
            ctx.fillStyle = '#00d4aa';
            ctx.font = 'bold 16px Arial';
            ctx.fillText(`${(face.probability * 100).toFixed(1)}%`, 
                face.topLeft[0], face.topLeft[1] - 10);
                
            ctx.setLineDash([]);
        }

        function drawEyeTracking(ctx, landmarks) {
            if (!landmarks.scaledMesh) return;
            
            // Enhanced eye visualization
            const leftEyeIndices = [33, 7, 163, 144, 145, 153, 154, 155, 133, 173];
            const rightEyeIndices = [362, 382, 381, 380, 374, 373, 390, 249, 263, 466];
            
            // Draw eye contours
            ctx.strokeStyle = '#667eea';
            ctx.lineWidth = 2;
            ctx.fillStyle = 'rgba(102, 126, 234, 0.3)';
            
            [leftEyeIndices, rightEyeIndices].forEach(eyeIndices => {
                ctx.beginPath();
                eyeIndices.forEach((index, i) => {
                    const [x, y] = landmarks.scaledMesh[index];
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                });
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
            });
            
            // Draw iris tracking if available
            if (landmarks.iris) {
                ctx.fillStyle = '#ff6b6b';
                landmarks.iris.forEach(iris => {
                    iris.forEach(point => {
                        ctx.beginPath();
                        ctx.arc(point[0], point[1], 2, 0, 2 * Math.PI);
                        ctx.fill();
                    });
                });
            }
        }

        function drawAdvancedMetrics(ctx) {
            // Enhanced overlay with advanced metrics
            ctx.fillStyle = 'white';
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 2;
            ctx.font = 'bold 14px Arial';
            
            const metrics = [
                `EAR: ${AdvancedState.averageEAR.toFixed(3)}`,
                `PERCLOS: ${AdvancedState.perclos.toFixed(1)}%`,
                `Blinks: ${AdvancedState.blinkCount}`,
                `Rate: ${AdvancedState.blinkRate.toFixed(1)}/min`,
                `Level: ${AdvancedState.drowsinessLevel}`,
                `Pose: ${AdvancedState.headPoseState}`
            ];
            
            metrics.forEach((text, i) => {
                const y = 25 + (i * 22);
                ctx.strokeText(text, 15, y);
                ctx.fillText(text, 15, y);
            });
            
            // Drowsiness warning
            if (AdvancedState.drowsinessLevel === 'High' || AdvancedState.drowsinessLevel === 'Critical') {
                ctx.fillStyle = AdvancedState.drowsinessLevel === 'Critical' ? '#ff3333' : '#ffaa00';
                ctx.font = 'bold 24px Arial';
                ctx.strokeStyle = 'black';
                ctx.lineWidth = 3;
                
                const warningText = `${AdvancedState.drowsinessLevel.toUpperCase()} DROWSINESS!`;
                const textWidth = ctx.measureText(warningText).width;
                const x = (640 - textWidth) / 2;
                
                ctx.strokeText(warningText, x, 60);
                ctx.fillText(warningText, x, 60);
            }
        }

        function resetDetectionValues() {
            AdvancedState.faceDetected = false;
            AdvancedState.faceConfidence = 0;
            AdvancedState.leftEAR = 0;
            AdvancedState.rightEAR = 0;
            AdvancedState.averageEAR = 0;
            AdvancedState.perclos = 0;
            AdvancedState.drowsinessLevel = 'Normal';
            AdvancedState.headPoseState = 'Unknown';
        }

        // Enhanced UI Updates
        function updateAdvancedUI() {
            // Main metrics
            document.getElementById('averageEARValue').textContent = AdvancedState.averageEAR.toFixed(3);
            document.getElementById('blinkCountValue').textContent = AdvancedState.blinkCount;
            document.getElementById('drowsyEventsValue').textContent = AdvancedState.drowsyEvents;
            
            // Advanced metrics
            document.getElementById('leftEARDisplay').textContent = AdvancedState.leftEAR.toFixed(3);
            document.getElementById('rightEARDisplay').textContent = AdvancedState.rightEAR.toFixed(3);
            document.getElementById('perclosDisplay').textContent = AdvancedState.perclos.toFixed(1);
            document.getElementById('blinkRateDisplay').textContent = AdvancedState.blinkRate.toFixed(1) + '/min';
            document.getElementById('faceConfidenceDisplay').textContent = (AdvancedState.faceConfidence * 100).toFixed(1) + '%';
            document.getElementById('headPoseDisplay').textContent = AdvancedState.headPoseState;
            document.getElementById('drowsinessLevelDisplay').textContent = AdvancedState.drowsinessLevel;
            
            // Update FPS
            const now = Date.now();
            if (now - AdvancedState.lastFpsUpdate >= 1000) {
                AdvancedState.fps = AdvancedState.frameCount;
                AdvancedState.frameCount = 0;
                AdvancedState.lastFpsUpdate = now;
                document.getElementById('fpsValue').textContent = AdvancedState.fps;
            }
        }

        function showAdvancedAlert(level) {
            const alertPanel = document.getElementById('alertPanel');
            const notification = document.getElementById('drowsinessNotification');
            const alertLevelSpan = document.getElementById('alertLevel');
            
            alertLevelSpan.textContent = level;
            alertPanel.classList.add('active');
            notification.classList.add('show');
            
            // Different durations based on severity
            const duration = level === 'CRITICAL' ? 6000 : 4000;
            
            setTimeout(() => {
                alertPanel.classList.remove('active');
                notification.classList.remove('show');
            }, duration);
        }

        // Enhanced Bluetooth Functions
        async function scanBluetooth() {
            if (!navigator.bluetooth) {
                log('Web Bluetooth not supported. Use Chrome/Edge with HTTPS.', 'error');
                return;
            }

            try {
                updateBluetoothStatus('scanning');
                log('Scanning for Bluetooth devices...', 'info');
                
                const device = await navigator.bluetooth.requestDevice({
                    acceptAllDevices: true,
                    optionalServices: [
                        'battery_service',
                        'device_information',
                        'generic_access',
                        '6e400001-b5a3-f393-e0a9-e50e24dcca9e', // Nordic UART
                        '12345678-1234-5678-9abc-def123456789', // Custom service
                        '0000ffe0-0000-1000-8000-00805f9b34fb'  // HM-10 default
                    ]
                });

                displayBluetoothDevice(device);
                await connectBluetoothDevice(device);
                
            } catch (error) {
                log(`Bluetooth scan failed: ${error.message}`, 'error');
                updateBluetoothStatus('disconnected');
            }
        }

        function displayBluetoothDevice(device) {
            const deviceList = document.getElementById('deviceList');
            deviceList.innerHTML = '';
            
            const deviceElement = document.createElement('div');
            deviceElement.className = 'device-item';
            
            deviceElement.innerHTML = `
                <div>
                    <strong>${device.name || 'Unknown Device'}</strong><br>
                    <small>ID: ${device.id}</small>
                </div>
                <button class="btn" style="padding: 8px 16px; font-size: 12px;">Connect</button>
            `;
            
            deviceList.appendChild(deviceElement);
        }

        async function connectBluetoothDevice(device) {
            try {
                updateBluetoothStatus('connecting');
                log(`Connecting to ${device.name || 'device'}...`, 'info');

                const server = await device.gatt.connect();
                AdvancedState.bluetoothDevice = device;
                
                // Try to find writable characteristic
                try {
                    const services = await server.getPrimaryServices();
                    for (const service of services) {
                        try {
                            const characteristics = await service.getCharacteristics();
                            for (const char of characteristics) {
                                if (char.properties.write || char.properties.writeWithoutResponse) {
                                    AdvancedState.bluetoothCharacteristic = char;
                                    break;
                                }
                            }
                            if (AdvancedState.bluetoothCharacteristic) break;
                        } catch (e) { continue; }
                    }
                } catch (e) {
                    log('Service discovery failed, using basic connection', 'warning');
                }

                device.addEventListener('gattserverdisconnected', () => {
                    log('Bluetooth device disconnected', 'warning');
                    AdvancedState.bluetoothDevice = null;
                    AdvancedState.bluetoothCharacteristic = null;
                    updateBluetoothStatus('disconnected');
                });
                
                updateBluetoothStatus('connected');
                await sendBluetoothCommand('D'); // Send acknowledgment
                log('Bluetooth connection established successfully!', 'success');
                
            } catch (error) {
                log(`Bluetooth connection failed: ${error.message}`, 'error');
                updateBluetoothStatus('disconnected');
            }
        }

        async function sendBluetoothCommand(command) {
            try {
                if (AdvancedState.bluetoothCharacteristic) {
                    const encoder = new TextEncoder();
                    await AdvancedState.bluetoothCharacteristic.writeValue(encoder.encode(command));
                    log(`BT TX: ${command}`, 'success');
                } else {
                    log(`Simulated TX: ${command}`, 'warning');
                }
                
                AdvancedState.lastCommand = command;
                AdvancedState.signalsSent++;
                return true;
            } catch (error) {
                log(`Bluetooth send error: ${error.message}`, 'error');
                return false;
            }
        }

        async function sendTestSignal() {
            log('Starting advanced Bluetooth test...', 'info');
            const testCommands = ['D', '0', '1', '0', '1', 'D'];
            
            for (const cmd of testCommands) {
                await sendBluetoothCommand(cmd);
                await new Promise(resolve => setTimeout(resolve, 1000));
            }
            
            log('Advanced Bluetooth test completed', 'success');
        }

        // Camera and Detection Control
        async function startCamera() {
            try {
                updateCameraStatus('starting');
                log('Initializing advanced camera system...', 'info');
                
                const constraints = {
                    video: {
                        width: { ideal: 640, max: 1280 },
                        height: { ideal: 480, max: 720 },
                        frameRate: { ideal: 30, max: 60 },
                        facingMode: 'user'
                    }
                };
                
                AdvancedState.videoStream = await navigator.mediaDevices.getUserMedia(constraints);
                const video = document.getElementById('videoElement');
                video.srcObject = AdvancedState.videoStream;
                
                await new Promise((resolve) => {
                    video.onloadedmetadata = () => {
                        video.play();
                        resolve();
                    };
                });
                
                AdvancedState.isCameraActive = true;
                updateCameraStatus('active');
                document.getElementById('startDetectionBtn').disabled = false;
                
                log('Advanced camera system ready', 'success');
                
            } catch (error) {
                log(`Camera initialization failed: ${error.message}`, 'error');
                updateCameraStatus('error');
            }
        }

        async function startDetection() {
            if (!AdvancedState.isCameraActive) {
                log('Please start camera first', 'error');
                return;
            }

            AdvancedState.isDetecting = true;
            updateDetectionStatus('active');
            
            if (!AdvancedState.isLogging) {
                toggleDataLogging();
            }
            
            log('Advanced AI drowsiness detection started', 'success');
            log(`Settings: EAR=${AdvancedState.earThreshold}, PERCLOS=${AdvancedState.perclosThreshold}%, Sensitivity=${getSensitivityText()}`, 'info');
            
            detectAdvancedDrowsiness();
        }

        // Settings Functions
        function updateEARThreshold(value) {
            AdvancedState.earThreshold = parseFloat(value);
            AdvancedState.blinkThreshold = parseFloat(value);
            document.getElementById('earThresholdValue').textContent = value;
            log(`EAR threshold updated to ${value}`, 'info');
        }

        function updatePERCLOSThreshold(value) {
            AdvancedState.perclosThreshold = parseInt(value);
            document.getElementById('perclosThresholdValue').textContent = value;
            log(`PERCLOS threshold updated to ${value}%`, 'info');
        }

        function updateSensitivity(value) {
            AdvancedState.sensitivity = parseInt(value);
            const sensitivityText = getSensitivityText();
            document.getElementById('sensitivityValue').textContent = sensitivityText;
            log(`Sensitivity updated to ${sensitivityText}`, 'info');
        }

        function getSensitivityText() {
            switch(AdvancedState.sensitivity) {
                case 1: return 'Low';
                case 2: return 'Medium';
                case 3: return 'High';
                default: return 'Medium';
            }
        }

        // Data Logging Functions
        function toggleDataLogging() {
            if (AdvancedState.isLogging) {
                stopDataLogging();
            } else {
                startDataLogging();
            }
        }

        function startDataLogging() {
            AdvancedState.isLogging = true;
            updateLoggingStatus('active');
            
            // Initialize enhanced CSV structure
            AdvancedState.csvData = [[
                'Timestamp_IST', 'Session_Time_Seconds', 'Face_Detected', 'Face_Confidence',
                'Left_EAR', 'Right_EAR', 'Average_EAR', 'PERCLOS_Percent', 
                'Blink_Count', 'Blink_Rate_Per_Min', 'Drowsy_Events', 'Drowsiness_Level',
                'Head_Pitch', 'Head_Yaw', 'Head_Roll', 'Head_Pose_State',
                'Alert_State', 'FPS', 'Bluetooth_Status', 'Command_Sent', 'Notes'
            ]];
            
            AdvancedState.sessionStart = Date.now();
            log('Enhanced data logging started', 'success');
        }

        function stopDataLogging() {
            AdvancedState.isLogging = false;
            updateLoggingStatus('inactive');
            log(`Enhanced data logging stopped. ${AdvancedState.recordCount} records saved.`, 'success');
        }

        function logAdvancedData(drowsinessAnalysis, notes = '') {
            if (!AdvancedState.isLogging) return;
            
            const sessionTime = AdvancedState.sessionStart ? 
                Math.floor((Date.now() - AdvancedState.sessionStart) / 1000) : 0;
            
            const record = [
                new Date().toLocaleString('en-IN', { timeZone: 'Asia/Kolkata' }),
                sessionTime,
                AdvancedState.faceDetected ? '1' : '0',
                (AdvancedState.faceConfidence * 100).toFixed(1),
                AdvancedState.leftEAR.toFixed(4),
                AdvancedState.rightEAR.toFixed(4),
                AdvancedState.averageEAR.toFixed(4),
                AdvancedState.perclos.toFixed(2),
                AdvancedState.blinkCount,
                AdvancedState.blinkRate.toFixed(1),
                AdvancedState.drowsyEvents,
                AdvancedState.drowsinessLevel,
                AdvancedState.headPose.pitch.toFixed(1),
                AdvancedState.headPose.yaw.toFixed(1),
                AdvancedState.headPose.roll.toFixed(1),
                AdvancedState.headPoseState,
                drowsinessAnalysis ? drowsinessAnalysis.level : 'Normal',
                AdvancedState.fps,
                AdvancedState.bluetoothDevice ? 'Connected' : 'Disconnected',
                AdvancedState.lastCommand,
                notes
            ];
            
            AdvancedState.csvData.push(record);
            AdvancedState.recordCount++;
            document.getElementById('dataRecordsValue').textContent = AdvancedState.recordCount;
        }

        function downloadCSV() {
            if (AdvancedState.csvData.length <= 1) {
                log('No data to download', 'warning');
                return;
            }
            
            const csvContent = AdvancedState.csvData.map(row => 
                row.map(cell => `"${cell}"`).join(',')
            ).join('\n');
            
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            
            const link = document.createElement('a');
            link.href = url;
            link.download = `advanced_drowsiness_data_${Date.now()}.csv`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
            
            log(`Enhanced CSV exported: ${AdvancedState.recordCount} records`, 'success');
        }

        // Status Update Functions
        function updateBluetoothStatus(status) {
            const indicator = document.getElementById('bluetoothIndicator');
            const statusText = document.getElementById('bluetoothStatusText');
            
            indicator.className = 'status-indicator';
            
            switch(status) {
                case 'connected':
                    indicator.classList.add('status-connected');
                    statusText.textContent = 'Connected';
                    document.getElementById('testBtn').disabled = false;
                    break;
                case 'connecting':
                    indicator.classList.add('status-connecting');
                    statusText.textContent = 'Connecting...';
                    break;
                case 'scanning':
                    indicator.classList.add('status-connecting');
                    statusText.textContent = 'Scanning...';
                    break;
                default:
                    indicator.classList.add('status-disconnected');
                    statusText.textContent = 'Disconnected';
                    document.getElementById('testBtn').disabled = true;
            }
        }

        function updateCameraStatus(status) {
            const indicator = document.getElementById('cameraIndicator');
            const statusText = document.getElementById('cameraStatusText');
            const button = document.getElementById('startCameraBtn');
            
            indicator.className = 'status-indicator';
            
            switch(status) {
                case 'active':
                    indicator.classList.add('status-connected');
                    statusText.textContent = 'Active';
                    button.textContent = 'Camera Running';
                    button.disabled = true;
                    break;
                case 'starting':
                    indicator.classList.add('status-connecting');
                    statusText.textContent = 'Starting...';
                    button.disabled = true;
                    break;
                case 'error':
                    indicator.classList.add('status-disconnected');
                    statusText.textContent = 'Error';
                    button.textContent = 'Retry Camera';
                    button.disabled = false;
                    break;
                default:
                    indicator.classList.add('status-disconnected');
                    statusText.textContent = 'Inactive';
                    button.textContent = 'Start Camera';
                    button.disabled = false;
            }
        }

        function updateDetectionStatus(status) {
            const indicator = document.getElementById('detectionIndicator');
            const statusText = document.getElementById('detectionStatusText');
            const button = document.getElementById('startDetectionBtn');
            
            indicator.className = 'status-indicator';
            
            if (status === 'active') {
                indicator.classList.add('status-connected');
                statusText.textContent = 'Active';
                button.textContent = 'AI Detection Running';
                button.disabled = true;
            } else {
                indicator.classList.add('status-disconnected');
                statusText.textContent = 'Standby';
                button.textContent = 'Start AI Detection';
                button.disabled = !AdvancedState.isCameraActive;
            }
        }

        function updateLoggingStatus(status) {
            const indicator = document.getElementById('loggingIndicator');
            const statusText = document.getElementById('loggingStatusText');
            const button = document.getElementById('dataLoggingBtn');
            
            indicator.className = 'status-indicator';
            
            if (status === 'active') {
                indicator.classList.add('status-connected');
                statusText.textContent = 'Recording';
                button.textContent = 'Stop Logging';
            } else {
                indicator.classList.add('status-disconnected');
                statusText.textContent = 'Inactive';
                button.textContent = 'Start Logging';
            }
        }

        // System Control Functions
        function stopAllSystems() {
            AdvancedState.isDetecting = false;
            
            // Stop camera
            if (AdvancedState.videoStream) {
                AdvancedState.videoStream.getTracks().forEach(track => track.stop());
                AdvancedState.videoStream = null;
                document.getElementById('videoElement').srcObject = null;
            }
            AdvancedState.isCameraActive = false;
            
            // Stop data logging
            if (AdvancedState.isLogging) {
                stopDataLogging();
            }
            
            // Disconnect Bluetooth
            if (AdvancedState.bluetoothDevice && AdvancedState.bluetoothDevice.gatt && AdvancedState.bluetoothDevice.gatt.connected) {
                AdvancedState.bluetoothDevice.gatt.disconnect();
            }
            
            // Clear canvas
            const canvas = document.getElementById('canvasOverlay');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Reset UI
            updateCameraStatus('inactive');
            updateDetectionStatus('inactive');
            updateLoggingStatus('inactive');
            updateBluetoothStatus('disconnected');
            
            // Reset all metrics
            resetDetectionValues();
            AdvancedState.blinkCount = 0;
            AdvancedState.drowsyEvents = 0;
            AdvancedState.blinkRate = 0;
            AdvancedState.earHistory = [];
            AdvancedState.perclosBuffer = [];
            updateAdvancedUI();
            
            log('All advanced systems stopped safely', 'warning');
        }

        // Session Timer
        function updateSessionTimer() {
            if (AdvancedState.sessionStart) {
                const elapsed = Math.floor((Date.now() - AdvancedState.sessionStart) / 1000);
                const hours = Math.floor(elapsed / 3600);
                const minutes = Math.floor((elapsed % 3600) / 60);
                const seconds = elapsed % 60;
                
                document.getElementById('sessionTimeValue').textContent = 
                    `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            }
        }

        // Logging System
        function log(message, type = 'info') {
            const container = document.getElementById('logContainer');
            const entry = document.createElement('div');
            entry.className = 'log-entry';
            
            const time = new Date().toLocaleTimeString('en-IN', {
                hour12: false,
                timeZone: 'Asia/Kolkata'
            });
            
            const typeClass = {
                'info': 'log-info',
                'warning': 'log-warning', 
                'error': 'log-error',
                'success': 'log-success'
            }[type] || 'log-info';
            
            entry.innerHTML = `<span class="log-timestamp">[${time}]</span> <span class="${typeClass}">${message}</span>`;
            container.appendChild(entry);
            container.scrollTop = container.scrollHeight;
            
            // Keep only last 150 entries for performance
            while (container.children.length > 150) {
                container.removeChild(container.firstChild);
            }
        }

        // Progress Update Function
        function updateProgress(percent, message) {
            document.getElementById('progressFill').style.width = `${percent}%`;
            document.getElementById('loadingTitle').textContent = message;
            
            if (percent === 100) {
                document.getElementById('loadingSubtitle').textContent = 'Advanced system ready!';
                document.getElementById('loadingDetails').textContent = 'Preparing enhanced interface...';
            }
        }

        function showMainInterface() {
            document.getElementById('loadingOverlay').style.display = 'none';
            document.getElementById('appContainer').style.display = 'grid';
            
            // Start session timer
            setInterval(updateSessionTimer, 1000);
            
            log('Advanced AI Drowsiness Detection System initialized', 'success');
            log('System ready with enhanced accuracy and multi-model detection', 'info');
        }

        // Initialize Application
        window.addEventListener('load', async () => {
            log('Initializing Advanced AI Drowsiness Detection System...', 'info');
            await initializeAdvancedAI();
        });

        // Cleanup on page unload
        window.addEventListener('beforeunload', () => {
            if (AdvancedState.videoStream) {
                AdvancedState.videoStream.getTracks().forEach(track => track.stop());
            }
            if (AdvancedState.bluetoothDevice && AdvancedState.bluetoothDevice.gatt && AdvancedState.bluetoothDevice.gatt.connected) {
                AdvancedState.bluetoothDevice.gatt.disconnect();
            }
        });
    </script>
</body>
</html>
